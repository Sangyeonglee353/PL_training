## 07 문자열 검색(string searching)
- 어떤 문자열 안에 다른 문자열이 포함되어 있는지 검사하고, 만약 포함되어 있다면 어디에 위치하는지 찾아애는 것
- 텍스트(text): 검색되는 쪽의 문자열
- 패턴(pattern): 찾아내는 문자열

### 07-1 브루트 포스법(brute force method) = 단순법
- 선형검색을 확장한 알고리즘
- 패턴을 하나씩 배열과 일치하는지 검사하는 형태
- 일치하지 않은 문자를 만나면 다시 패턴의 첫 문자부터 검사를 수행

### 07-2 KMP법(Knuth-Morris-Pratt법)
- 검사했던 결과를 버리지 않고 효율적으로 활용하는 알고리즘
- 텍스트와 패턴 안에서 겹치는 문자열을 찾아내 검사를 다시 시작할 위치를 구하여 패턴의 이동을 되도록이면 크게하는 알고리즘
- 몇 번째 문자부터 다시 검색할지 값을 표(건너뛰기 표, skip table)로 만들어 문제 해결

### 07-3 보이어•무어법
- 패턴의 끝 문자에서 시작하여 앞쪽을 향해 검사를 수행하는 알고리즘
- 원래 2개의 배열을 사용하여 검사함

ex. 텍스트: ABCXDEZCABACABAC / 패턴: ABAC    

패턴에 포함되지 않는 문자를 만난 경우
- 패턴 이동량이 곧 n입니다. 'X'는 패턴에 포함되지 않으므로 4문자만큼 밀어냅니다.

패턴에 포함되는 문자를 만난 경우
- 마지막에 나오는 위치의 인덱스가 k이면 이동량은 n - k - 1입니다. 'A'는 패턴 안의 두 곳에 있습니다. 패턴을 오른쪽으로 1칸 밀어냅니다.
- 같은 문자가 패턴 안에 중복해서 존재하지 않으면 패턴의 맨 끝 문자의 이동량은 n입니다. 예를 들어 'ABAC'의 'C'를 만나면 이동할 필요가 없으므로 이동량은 n입니다.

### 문자열 검색 알고리즘의 시간 복잡도
- 텍스트의 길이 = n
- 패턴의 길이 = m

#### 브루트 포스법
- 이 알고리즘의 시간 복잡도는 O(mn)이지만 일부러 꾸며 낸 패턴이 아니라면 O(n)이 된다고 알려져 있습니다. 단순한 알고리즘이지만 실제로는 아주 빠르게 동작합니다.

#### KMP법
- 이 알고리즘의 시간 복잡도는 최악의 경우에도 O(n)입니다. 다만 처리하기 복잡하고 패턴 안에 반복이 없으면 효율은 좋지 않습니다. 그러나 검색 과정에서 주목하는 곳을 앞으로 되돌릴 필요가 전혀 없으므로 파일을 차례로 읽어 들이면서 검색할 때 사용하면 좋습니다.

#### 보이어•무어법
- 이 알고리즘의 시간 복잡도는 최악의 경우라도 O(n)이고 평균 O(n / m)입니다. bm_match.py 에서는 배열을 1개만 사용했지만 배열 2개로 알고리즘을 구현하면 KMP법과 마찬가지로 배열을 만드는 데 복잡한 처리 과정이 필요하므로 효율성이 떨어집니다. 보이어•무어법은 배열을 1개만 사용해도 충분히 빠릅니다.