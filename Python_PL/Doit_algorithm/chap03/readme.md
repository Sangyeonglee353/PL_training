## 검색 알고리즘

### 검색의 종류
1. 선형 검색: 무작위로 늘어놓은 데이터 집합에서 검색을 수행합니다.
- 순차 검색(sequential search)이라고도 합니다.
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색을 수행합니다.   
(단, 이진 검색은 정렬이 필수!!)
3. 해시법: 추가•삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색을 수행합니다.
- 체인법: 같은 해시값 데이터를 연결 리스트로 연결하는 방법입니다.
- 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법입니다.

### 1. 선형 검색
- 선형 검색은 배열의 원소를 맨 앞부터 순서대로 스캔하여 검색합니다.

#### 선형 검색의 종료 조건
1. 검색할 값을 찾지 못하고 배열의 맨 끝을 지나간 경우 ⋯ 검색 실패
2. 검색할 값과 같은 원소를 찾은 경우 ⋯ 검색 성공

#### 보초법(sentinel method)
- 검색할 값과 같은 원소를 발견해야 하므로 맨 끝에 도달했는지 판단이 필요없어 집니다.

### 2. 이진 검색
- 이진 검색은 원소가 오름차순이나 내림차순으로 정렬된 배열에서 좀 더 효율적입니다.

- 검색 범위의 맨 앞의 인덱스: pl
- 검색 범위의 맨 끝의 인덱스: pr
- 검색 범위의 중앙의 인덱스: pc

검색을 시작할 때, pl = 0, pr = n - 1, pc = (n-1) // 2로 초기화

1. a[pc] < key : 중앙(pc)에서 오른쪽으로 한 칸 이동하여 새로운 왼쪽 끝 pl로 지정하고, 검색 범위를 뒤쪽 절반으로 좁힙니다.
2. a[pc] > key : 중앙(pc)에서 왼쪽으로 한 칸 이동하여 새로운 오른쪽 끝 pr로 지정하고, 검색 범위를 앞쪽 절반으로 좁힙니다.

#### 이진 검색의 종료 조건
1. a[pc]와 key가 일치하는 경우
2. 검색 범위가 더 이상 없는 경우

#### 복잡도
- 시간 복잡도(time complexity): 실행하는 데 필요한 시간을 평가합니다.
- 공간 복잡도(space complexity): 메모리(기억 공간)와 파일 공간이 얼마나 필요한지를 평가합니다.
- 복잡도를 표기할 때 사용하는 O는 order의 머리글자(initial)입니다. O(n)은 n의 오더 또는 오더 n이라고 읽습니다.
- 전체 복잡도는 차원이 가장 높은 복잡도를 선택합니다.   
ex. O(f(n)) + O(g(n)) = O(max(f(n), g(n)))   
따라서, 선형 검색 알고리즘의 복잡도는 O(n) / 이진 검색 알고리즘의 시간 복잡도는 O(log n)

#### 복잡도와 증가율
1 < log n < n < n log n < n^2 < n^3 < n^k < 2^n


### 3. 해시법(hashing)
- 해시(hash): 긁어모음, 뒤죽박죽, 가늘게 썬 고기 음식
- 해시법은 검색과 더불어 데이터의 추가•삭제도 효율적으로 수행가능합니다.
- '데이터를 저장할 위치 = 인덱스'를 간단한 연산으로 구하는 것
- 해시값(hash value or digest): 배열의 키(원소의 값)를 원소 개수로 나눈 나머지
- 해시 테이블: 해시값을 인덱스로 하여 원소를 새로 저장한 배열
- 해시 함수(hash function): 키를 해시값으로 변환하는 과정
- 버킷(buckey): 해시 테이블에서 만들어진 원소
- 해시 충돌(collision): 저장할 버킷이 중복되는 현상

#### 3-1. 체인법(ChainedHash) = 열린 해시법(open hashing)
- 해시값이 같은 원소를 연결 리스트로 관리합니다.

#### 참고
- sha256 알고리즘: hashlib 모듈에서 제공하는 sha256은 RSA의 FIPS 알고리즘을 바탕으로 하며, 주어진 바이트(byte) 문자열의 해시값을 구하는 해시 알고리즘의 생성자(constructor)입니다. hashlib모듈은 sha256 외에도 MD5 알고리즘인 md5 등 다양한 해시 알고리즘을 제공합니다.
- endcode() 함수: hashlib.sha256에는 바이트 문자열의 인수를 전달해야 합니다. 그래서 key를 str형 문자열로 변환한 뒤 그 문자열을 encode() 함수에 전달하여 바이트 문자열을 생성합니다.
- hexdigest() 함수: sha256 알고리즘에서 해시값을 16진수 문자열로 꺼냅니다.
- int() 함수: hexdigest() 함수로 꺼낸 문자열을 16진수 문자열로 하는 int형으로 변환합니다.

해시 검색_search() 함수의 검색 과정
1. 해시 함수를 사용하여 키를 해시값으로 변환합니다.
2. 해시값을 인덱스로 하는 버킷에 주목합니다.
3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 스캔합니다. 키와 같은 값이 발견되면 검색에 성공하고, 원소의 맨 끝까지 스캔해서 발견되지 않으면 검색에 실패합니다.

해시 검색_add() 함수의 원소 추가 과정
1. 해시 함수를 사용하여 키를 해시값으로 변환합니다.
2. 해시값을 인덱스로 하는 버킷에 주목합니다.
3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 선형 검색을 합니다. 키와 같은 값이 발견되면 키가 이미 등록된 경우이므로 추가에 실패합니다. 원소의 맨 끝까지 발견되지 않으면 리스트의 맨 앞에 노드를 추가합니다.

해시 검색_remove() 함수의 원소 삭제 과정
1. 해시 함수를 사용하여 키를 해시값으로 변환합니다.
2. 해시값을 인덱스로 하는 버킷에 주목합니다.
3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 선형 검색합니다. 키와 같은 값이 발견되면 그 노드를 리스트에서 삭제합니다. 그렇지 않으면 삭제에 실패합니다.

#### 3-2. 오픈 주소법(open addressing) = 닫힌 해시법(closed hashing)
- 충돌이 발생했을 때 재해시(rehashing)를 수행하여 빈 버킷을 찾는 방법

원소 추가할 때
- 선형 탐사법(linear probing): 빈 버킷이 나올 때까지 재해시를 반복

원소 삭제할 때
- 존재하지 않는다고 착각하는 오류를 방지하기 위해 각 버킷에 다음과 같은 속성을 부여합니다.
1. 데이터가 저장되어 있음(숫자)
2. 비어 있음(-)
3. 삭제 완료(★)