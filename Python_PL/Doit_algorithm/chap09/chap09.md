## 09 트리

### 09-1 트리 구조
- 루트(root): 트리에서 가장 위쪽에 있는 노드
- 리프(leaf) = 단말 노드(terminal node) = 외부 노드(external node): 가장 아래쪽에 있는 노드 → 가지가 더 이상 뻗어나갈 수 없는 마지막에 있는 노드
- 비단말 노드(non-terminal node) = 내부 노드(internal node): 리프를 제외한 노드(루트를 포함)
- 자식(child): 어떤 노드와 가지가 연결되었을 때 아래쪽 노드
- 부모(parent): 어떤 노드와 가지가 연결되었을 때 위족 노드
- 형제(sibling): 부모가 같은 노드
- 조상(ancestor): 어떤 노드에서 위쪽으로 가지를 따라가면 만나는 모든 노드
- 자손(descendant): 어떤 노드에서 아래쪽으로 가지를 따라가면 만나는 모든 노드
- 레벨(level): 루트에서 얼마나 멀리 떨어져 있는지를 나타낸 것
- 차수(degree): 각 노드가 갖는 자식의 수
- 높이(height): 루트에서 가장 멀리 있는 리프까지의 거리 = 리프 레벨의 최댓값
- 서브트리(subtree): 어떤 노드를 루트로 하고, 그 자손으로 구성된 트리
- 빈 트리(None tree) = 널 트리(null tree): 노드와 가지가 전혀 없는 트리
- 순서 트리(ordered tree): 형제 노드의 순서 관계가 있는 경우
- 무순서 트리(unordered tree): 형제 노드의 순서를 구별하지 않는 경우

### 순서 트리의 검색
- 너비 우선 검색(breadth-first search) = 폭 우선 검색, 가로 검색, 수평 검색: 낮은 레벨부터 왼쪽에서 오른쪽으로 검색하고, 한 레벨에서 검색을 마치면 다음 레벨로 내려가는 방법
- 깊이 우선 탐색(depth-first search) = 세로 검색, 수직 검색: 리프에 도달할 때까지 아래쪽으로 내려가면서 검색하는 것을 우선으로하는 방법
- 깊이 우선 탐색의 3가지 스캔 방법
1. 전위 순회(preorder): 노드 방문 → 왼쪽 자식 → 오른쪽 자식
2. 중위 순회(inorder): 왼쪽 자식 → 노드 방문 → 오른쪽 자식
3. 후위 순회(postorder): 왼쪽 자식 → 오른쪽 자식 → 노드 방문

### 09-2 이진 트리와 이진 검색 트리
- 이진 트리(binary tree): 노드가 왼쪽 자식(left child)와 오른쪽 자식(right child)만을 갖는 트리
- 왼쪽 서브트리(left subtree): 왼쪽 자식을 루트로 하는 서브트리
- 오른쪽 서브트리(right subtree): 오른쪽 자식을 루트로 하는 서브트리
- 완전 이진 트리(complete binary tree)
    - 마지막 레벨을 제외하고 모든 레벨에 노드가 가득 차 있습니다.
    - 마지막 레벨에 한해서 왼쪽부터 오른쪽으로 노드를 채우되 반드시 끝까지 채우지 않아도 됩니다.
- 균형 검색 트리(self-balancing search tree): 높이를 O(log n)으로 제한하여 키의 오름차순으로 노드가 삽입될 시 트리의 높이가 깊어지는 단점을 해결   
ex1. 이진의 균형 검색 트리: AVL 트리(AVL tree), 레드•블랙 트리(red-black tree)   
ex2. 일반 균형 검색 트리: B 트리(B tree), 2-3 트리(2-3 tree)

#### 이진 검색 트리의 특징
- 왼쪽 서브트리 노드의 키값은 자신의 노드 키값보다 작아야 합니다.
- 오른쪽 서브트리 노드의 키값은 자신의 노드 키값보다 커야 합니다.
- 구조가 단순합니다.
- 중위 순회의 깊이 우선 검색을 통하여 노드값을 오름차순으로 얻을 수 있습니다.
- 이진 검색과 비슷한 방식으로 아주 빠르게 검색할 수 있습니다.
- 노드를 삽입하기 쉽습니다.

#### search() 알고리즘
1. 루트에 주목합니다. 여기서 주목하는 노드를 p라고 하겠습니다.
2. p가 None이면 검색을 실패하고 종료합니다.
3. 검색하는 key와 주목 노드 p의 키를 비교합니다.
    - key = p: 검색을 성공하고 종료합니다.
    - key < p: 주목 노드를 왼쪽 자식 노드로 옮깁니다.
    - key > p: 주목 노드를 오른쪽 자식 노드로 옮깁니다.
4. 2번 과정으로 되돌아갑니다.

#### add() 알고리즘
1. 루트에 주목합니다. 여기서 주목하는 노드를 node라고 하겠습니다.
2. 삽입하는 key와 주목 노드 node의 키를 비교합니다.
    - key = node인 경우: 삽입을 실패하고 종료합니다.
    - key < node인 경우:
        - 왼쪽 자식 노드가 없으면, 그 자리에 노드를 삽입하고 종료합니다.
        - 왼쪽 자식 노드가 있으면, 주목 노드를 왼쪽 자식 노드로 옮깁니다.
    - key > node:
        - 오른쪽 자식 노드가 없으면, 그 자리에 노드를 삽입하고 종료합니다.
        - 오른쪽 자식 노드가 있으면, 주목 노드를 오른쪽 자식 노드로 옮깁니다.
3. 2번 과정으로 되돌아갑니다.

#### remove() 알고리즘
1. 자식 노드가 없는 노드를 삭제하는 경우
- 삭제할 노드가 부모 노드의 왼쪽 자식이면, 부모의 왼쪽 포인터를 None으로 합니다.
- 삭제할 노드가 부모 노드의 오른쪽 자식이면, 부모의 오른쪽 포인터를 None으로 합니다.
2. 자식 노드가 1개인 노드를 삭제하는 경우
- 삭제할 노드가 부모 노드의 왼쪽 자식인 경우: 부모의 왼쪽 포인터가 삭제할 노드의 자식을 가리키도록 업데이트합니다.
- 삭제할 노드가 부모 노드의 오른쪽 자식인 경우: 부모의 오른쪽 포인터가 삭제할 노드의 자식을 가리키도록 업데이트합니다.
3. 자식 노드가 2개인 노드를 삭제하는 경우
- 삭제할 노드의 왼쪽 서브트리에서 키값이 가장 큰 노드를 검색합니다.
- 검색한 노드를 삭제 위치로 옮깁니다. 즉, 검색한 노드의 데이터를 삭제할 노드 위치에 복사합니다.
- 옮긴 노드를 삭제합니다. 이때 자식 노드의 개수에 따라 다음을 수행합니다.
    - 옮긴 노드에 자식이 없으면: '자식 노드가 없는 노드의 삭제'에 따라 노드를 삭제합니다.
    - 옮긴 노드에 자식이 1개만 있으면: '자식 노드가 1개인 노드의 삭제'에 따라 노드를 삭제합니다.