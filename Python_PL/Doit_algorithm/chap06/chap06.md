### 06-1 정렬 알고리즘
- 오름차순 정렬: 점점 값이 커지는 정렬
- 내림차순 정렬: 점점 값이 작아지는 정렬
- 내부 정렬(internal sorting): 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
- 외부 정렬(external sorting): 정렬할 데이터가 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘 → 별도의 작업용 파일 필요
- 정렬 알고리즘의 핵심은 교환•선택•삽입이다.

### 06-2 버블 정렬(bubble sorting) = 단순 교환 정렬
- 이웃한 두 원소의 대소 관계를 비교하여 필요에 따라 교환을 반복하는 알고리즘
- 패스(pass): 일련의 비교•교환하는 과정
- 원소 수가 n인 배열에서 n-1번 비교•교환을 하면 가장 작은 원소가 맨 앞으로 이동한다.
- 시간 복잡도: O(n<sup>2</sup>)

### 06-3 단순 선택 정렬(straight selection sort)
- 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하며 정렬하는 알고리즘
- 시간 복잡도: O(n<sup>2</sup>)

#### 단순 선택 정렬에서 교환 과정
1. 아직 정렬되지 않은 부분에서 값이 가장 작은 원소 a[min]을 선택합니다.
2. a[min]과 아직 정렬하지 않은 부분에서 맨 앞에 있는 원소를 교환합니다.

### 06-4 단순 삽입 정렬(straight insertion sort) = 셔틀 정렬(shuttle sort)
- 주목한 원소보다 더 앞쪽에서 알맞은 위치로 삽입하며 정렬하는 알고리즘
- 단순 선택 정렬과 차이점: 가장 작은 원소를 선택하지 않는다는 점
- 장점: 이미 정렬을 마쳤거나 정렬이 거의 끝나가는 상태에서는 속도가 아주 빠르다.
- 단점: 삽입할 위치가 멀리 떨어져 있으면 이동 횟수가 많아진다.
- 시간 복잡도: O(n<sup>2</sup>)

#### 단순 삽입 정렬에서 교환 과정
1. 정렬되지 않은 부분의 맨 앞 원소를 주목한다.
2. 주목한 원소를 정렬된 부분의 알맞은 위치에 삽입한다.
3. 이 과정을 n - 1번 반복한다.
- 종료 조건 1: 정렬된 배열의 왼쪽 끝에 도달한 경우
- 종료 조건 2: tmp보다 작거나 키값이 같은 원소 a[j-1]을 발견할 경우
- 계속 조건 1: j가 0보다 큰 경우
- 계속 조건 2: a[j - 1]의 값이 tmp보다 큰 경우
- 원소의 비교 횟수와 교환 횟수: n<sup>2</sup> / 2번

#### 이진 삽입 정렬(binary insertion sort)
- 단순 삽입 정렬에 이진 검색 알고리즘을 조합
- 장점: 이미 정렬을 마친 배열을 제외하고 원소를 삽입해야 할 위치를 검사하므로 비용 감소
- bisect 모듈의 insort() 함수로도 구현 가능

### 06-5 셸 정렬(Shell sort)
- 단순 삽입 정렬의 장점은 살리고 단점은 보완한 알고리즘
- 그룹별로 정렬한 뒤 마지막에 단순 삽입 정렬 실행
- 그룹을 나누는 기준: 서로 얼마나 떨어져 있는지
- 단점: 그룹이 섞이지 않는 문제 발생
- h의 값이 서로 배수가 되지 않도록 h * 3 + 1 수열을 사용하여 보완
- 시간 복잡도: n<sup>1.25</sup>

### 06-6 퀵 정렬(Quick sort)
- 가장 빠른 정렬 알고리즘
- 피벗(pivot, 중심축) 선택하여 그룹을 나눠 정렬하는 알고리즘
- 피벗: x
- 왼쪽 커서(왼쪽 끝 원소의 인덱스): pl
- 오른쪽 커서(오른쪽 끝 원소의 인덱스): pr

#### 그룹 나누기 작업
1. a[pl] >= x가 성립하는 원소를 찾을 때까지 pl을 오른쪽 방향으로 스캔합니다.
2. a[pr] <= x가 성립하는 원소를 찾을 때까지 pr을 왼쪽 방향으로 스캔합니다.

#### 개선
: 원소 수가 1개인 그룹은 더 이상 나눌 필요가 없으므로 원소 수 2개 이상인 그룹만 다음과 같이 반복해서 나눕니다.
1. pr가 a[0]보다 오른쪽에 위치하면(left < pr) 왼쪽 그룹을 나눕니다.
2. pl이 a[0]보다 왼쪽에 위치하면(pl < right) 오른쪽 그룹을 나눕니다.

#### 비재귀적인 퀵 정렬 구현하기 → stack 사용
[배열을 스택에 푸시하는 순서 정하기]
- 규칙 1: 원소 수가 많은 쪽의 그룹을 먼저 푸시 
- 규칙 2: 원소 수가 적은 쪽의 그룹을 먼저 푸시 
- 스택에 넣고 꺼내는 횟수(푸시, 팝)은 같으나, 동시에 쌓이는 데이터의 최대 개수가 다름
- 규칙 1의 경우 배열의 원소 수가 n이면 스택에 쌓이는 데이터의 최대 개수는 log n 보다 적음

#### 피벗 선택하기
- 방법 1: 나누어야 할 배열의 원소 수가 3이상이면, 배열에서 임의의 원소 3개를 꺼내 중앙값인 원소를 피벗으로 선택합니다.
- 방법 2: 나누어야 할 배열의 맨 앞 원소, 가운데 원소, 맨 끝 원소를 정렬한 뒤 가운데 원소와 맨 끝에서 두 번째 원소를 교환합니다.
맨 끝에서 두 번째 원솟값 a[right - 1]이 피벗으로 선택되었고, 그 동시에 나눌 대상을 a[left + 1] ~ a[right - 2]로 좁힙니다.

#### sorted() 함수로 정렬하기
- 정렬을 직접 수행하지 않고 정렬을 수행한 뒤 늘어선 원소를 새로운 리스트로 생성하여 반환
